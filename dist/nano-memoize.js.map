{"mappings":"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","sources":["src/index.js"],"sourcesContent":["/*\r\nMIT License\r\n\r\nCopyright (c) 2018-2023 Simon Y. Blackwell\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\n\tThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n*/\r\n\r\n\r\n\tvar assign = Object.assign;\r\nif(typeof(assign)!==\"function\") {\r\n\tassign = function() {\r\n\t\tvar a = arguments,\r\n\t\t\to = arguments[0];\r\n\t\tif (o === null || o === undefined) {\r\n\t\t\tthrow new TypeError(\"Cannot convert undefined or null to object\");\r\n\t\t}\r\n\t\to = Object(o);\r\n\t\tfor(var i=1;i<a.length;i++) {\r\n\t\t\tif(a[i] && typeof(a[i])===\"object\") {\r\n\t\t\t\tfor(var k in a[i]) {\r\n\t\t\t\t\to[k] = a[i][k];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn o;\r\n\t};\r\n}\r\nfunction vrgs(f) {\r\n\t\tvar s = f+\"\",\r\n\t\t\ti = s.indexOf(\"...\");\r\n\t\treturn i>=0 && (i<s.indexOf(\")\") || s.indexOf(\"arguments\")>=0);\r\n}\r\nfunction nanomemoize(fn,o) {\r\n\t/*o = {\r\n\t\tserializer, // used to serialize arguments of single argument functions, multis are not serialized\r\n\t\tequals, // equality tester, will force use of slower multiarg approach even for single arg functions\r\n\t\tmaxAge, // max cache age is ms, set > 0 && < Infinity if you want automatic clearing\r\n\t\tmaxArgs, // max args to use for signature\r\n\t\tvargs = vrgs(fn) // set to true if function may have variable or beyond-signature arguments, default is best attempt at infering\r\n\t  } = {}\r\n\t*/\r\n\to || (o={});\r\n\tvar vargs = o.vargs || vrgs(fn),\r\n\t\ts = Object.create(null), // single arg function key/value cache\r\n\t\tk = [], // multiple arg function arg key cache\r\n\t\tv = [], // multiple arg function result cache\r\n\t\tz, // index of zero arg result in v\r\n\t\tcache = new Map(),\r\n\t\td = function(key,c,k) { return setTimeout(function() {\r\n\t\t\t\tif(k) { // dealing with multi-arg function, c and k are Arrays\r\n\t\t\t\t\tc.splice (key,1);\r\n\t\t\t\t\tk.splice(key,1);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t} // dealing with single arg function, c is a WekMap or Object\r\n\t\t\t\tc instanceof Map  ? c.delete(key) : delete c[key];\r\n\t\t\t},o.maxAge); },\r\n\t\tc = o.maxAge>0 && o.maxAge<Infinity ? d : 0, // cache change timeout,\r\n\t\teq = o.equals ? o.equals : function(a,b) { return a===b; },\r\n\t\tmaxargs = o.maxArgs,\r\n\t\tsrlz = o.serializer,\r\n\t\tf, // memoized function to return\r\n\t\tu; // flag indicating a unary arg function is in use for clear operation\r\n\t\tif(fn.length===1 && !o.equals && !vargs) {\r\n\t\t\t// for single argument functions, just use a Map lookup\r\n\t\t\tf =  function(a) {\r\n\t\t\t\t\tif(srlz) a = srlz(a);\r\n\t\t\t\t\tvar r;\r\n\t\t\t\t\treturn cache.get(a) || ((!c||c(a,cache)),cache.set(a,r = fn.call(this, a)),r);\r\n\t\t\t};\r\n\t\t\tu = 1;\r\n\t\t} else {\r\n\t\t// for multiple arg functions, loop through a cache of all the args\r\n\t\t// looking at each arg separately so a test can abort as soon as possible\r\n\t\tf = function() {\r\n\t\t\tif(arguments.length || o.equals) {\r\n\t\t\t\tvar l = maxargs||arguments.length, kl = k.length, i=kl;\r\n\t\t\t\twhile(--i>=0) { // an array of arrays of args, each array represents a call signature\r\n\t\t\t\t\tif (!maxargs && k[i].length !== l) continue; // cache miss if called with a different number of args\r\n\t\t\t\t\tvar j=l-1;\r\n\t\t\t\t\twhile(j-->=0 && (o.equals ? o.equals(k[i][j],arguments[j]) : k[i][j]===arguments[i])) {\t// compare each arg\tworking back from length or args || maxargs\r\n\t\t\t\t\t\tif(j===0) { return v[i]; } // the args matched\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\ti = kl - (i + 1);\r\n\t\t\t\t// set change timeout only when new value computed, hits will not push out the tte, but it is arguable they should not\r\n\t\t\t\treturn (!c||c(i,v,k)),v[i] = fn.apply(this,k[i] = arguments);\r\n\t\t\t} // set change timeout only when new value computed, hits will not push out the tte, but it is arguable they should not\r\n\t\t\treturn z===undefined ? ((!c||c(0,v,k)),z = fn.apply(this,arguments)) : z;\r\n\t\t};\r\n\t}\r\n\t// reset all the caches\r\n\tf.clear = function() {\r\n\t\tcache = new Map();\r\n\t\ts = Object.create(null);\r\n\t\tk = [];\r\n\t\tv = [];\r\n\t\tz = undefined;\r\n\t};\r\n\tf.keys = function() { return u ? [...cache.keys()] : k.slice(); };\r\n\tf.values = function() { return u ? [...cache.values()] : v.slice(); };\r\n\treturn f;\r\n}\r\n\r\nexport {nanomemoize,nanomemoize as default}\r\n\r\n"],"names":[],"version":3,"file":"nano-memoize.js.map"}